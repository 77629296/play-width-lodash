{"./":{"url":"./","title":"Introduction","keywords":"","body":"写点什么 路已铺好，如何贡献，那是追求。 By leeson            此页面修订于： 2021-03-31 15:14:31 "},"JavaScript设计模式/":{"url":"JavaScript设计模式/","title":"JavaScript设计模式","keywords":"","body":"JavaScript设计模式与开发实践 设计模式 设计模式看似遥远，但实际开发中我们一直在用，只是没有明确说，我用了某某模式而已，系统的学习设计模式，能够提升代码的设计感与成就感，在不知道如何设计的时候，有现成的套路可以参考 开发实践 \b学习当然不能仅停留在理论上，结合实际业务场景，提取一些公共代码，套用一下设计模式，提升代码的可读性和可维护性 By leeson            此页面修订于： 2021-03-31 15:14:31 "},"JavaScript设计模式/1-面向对象.html":{"url":"JavaScript设计模式/1-面向对象.html","title":"面向对象","keywords":"","body":"第一章 面向对象的 JavaScript 多态的含义 因为 js 是动态类型语言，所以不需要转型来达到多态的效果，这里使用 ts 模拟 同一方法在不同对象上表现不同，比如动物都有发出叫声这个方法，鸡和鸭的声音不同，代码如下 // 在线运行ts https://c.runoob.com/compile/5577 abstract class Animal { abstract makeSound(): void } class Chicken extends Animal { public makeSound(): void { console.log('咯咯咯') } } class Duck extends Animal { public makeSound(): void { console.log('嘎嘎嘎') } } const chicken: Chicken = new Chicken() chicken.makeSound() //咯咯咯 const duck: Duck = new Duck() duck.makeSound() //嘎嘎嘎 // 根据实际类型调用方法 const animalMakeSound = (animal: Duck | Chicken) => { animal.makeSound() } animalMakeSound(chicken) animalMakeSound(duck) 多态的使用 var googleMap = { show: function () { console.log('开始渲染谷歌地图') }, } var baiduMap = { show: function () { console.log('开始渲染百度地图') }, } // 后续增加类型 需要修改原代码 var renderMap = function (type) { if (type === 'google') { googleMap.show() } else if (type === 'baidu') { baiduMap.show() } } renderMap('google') // 输出：开始渲染谷歌地图 renderMap('baidu') // 输出：开始渲染百度地图 /** * 修改后 * 抽象相同的show方法，不同的地图对象都实现show方法 */ var renderMap = function (map) { if (map.show instanceof Function) { map.show() } } renderMap(googleMap) renderMap(baiduMap) // 新增一种地图时，只需增加地图对象并实现show方法，无需改动renderMap var sosoMap = { show: function () { console.log('开始渲染搜搜地图') }, } renderMap(sosoMap) // 输出：开始渲染搜搜地图 三种创建对象的方式 前两种 字面量、object 构造器 从下面这两个判断可以看出 两者是等价的，都是创建一个空的对象，proto指向 Object.prototype // 1、{} // 2、new Object() ;({}.__proto__ === Object.prototype) // true new Object().__proto__ === Object.prototype // true 第三种 Object.create({}) 创建一个空的对象 proto指向第一个参数 /** * 先看一下方法签名 * proto 必须有，表示新建对象的原型对象 * propertiesObject 添加到新创建对象的可枚举属性 */ Object.create(proto, [propertiesObject]) /** * 3、Object.create({}) * 新建一个空对象{}，{}的__proto__指向参数{} * 参数{}的__proto__指向Object.prototype */ Object.create({}).__proto__.__proto__ === Object.prototype // true Object.create(Object.prototype).__proto__ === Object.prototype // true // 新建一个真空对象 Object.create(null) Object.create(null).__proto__ // undefined 模拟实现 new 方法 // 调用方式：const foo = mockNew(Foo, ...others) function mockNew(...args) { // 1.取出args数组第一个参数，也就是构造函数 const constructor = args.shift() // 2.创建一个空对象 且让这个空对象继承构造函数的prototype属性 const newObj = Object.create(constructor.prototype) // 3.执行构造函数，得到返回结果 const result = constructor.apply(newObj, args) // 4.如果返回值类型是对象，这直接返回该对象，否则返回新对象 return typeof result === 'object' && result != null ? result : newObj } By leeson            此页面修订于： 2021-03-31 15:14:31 "},"JavaScript设计模式/2-bind与apply实现.html":{"url":"JavaScript设计模式/2-bind与apply实现.html","title":"bind与apply实现","keywords":"","body":"第二章 bind 与 apply 实现 bind Function.prototype.mockBind = function (context) { // this就是调用方，也就是需要绑定this的函数 var that = this // 截取调用mockBind时，传入的其他参数 var args = Array.prototype.slice.call(arguments, 1) // 处理new关键字调用的场景 var F = function () {} // 指向调用方的构造函数 F.prototype = this.prototype var innerBind = function () { // 此时arguments是mockBind返回的函数，再次调用时传入的参数 var innerArgs = Array.prototype.slice.call(arguments) // 合并参数 var finalArgs = args.concat(innerArgs) // 如果是F的示例 说明是使用new关键字调用 return that.apply(this instanceof F ? this : context || this, finalArgs) } innerBind.prototype = new F() return innerBind } 测试一下 function sourceFoo(a) { this.a = a } const targetObj = {} var bindFoo = sourceFoo.mockBind(targetObj) bindFoo(2) console.log(targetObj.a) // 2 var newBindObj = new bindFoo(3) console.log(newBindObj.a) // 3 apply Function.prototype.mockApply = function (context) { var args = Array.prototype.slice.call(arguments, 1) if (typeof context === 'object') { context = context || window } else { context = Object.create(null) } //es6 symbol()表示唯一值；作为属性的时候，不能使用点运算符 var targetFnKey = Symbol() // 函数体内的this指向调用mockApply的函数 context[targetFnKey] = this // 隐式绑定 把函数体内的this绑定到context上 var result = context[targetFnKey](...args) delete context[targetFnKey] return result } 测试一下 function sourceFoo(a) { this.a = a console.log(this) } var targetObj = {} // targetObj = { // Symbol(): ƒ // } // 如上所示，再次调用f时 f内的this就指向了targetObj 参考定律4：上下文对象隐式绑定 sourceFoo.mockApply(targetObj, 2) By leeson            此页面修订于： 2021-03-31 15:14:31 "},"JavaScript设计模式/2-this到底指向谁.html":{"url":"JavaScript设计模式/2-this到底指向谁.html","title":"this到底指向谁","keywords":"","body":"第二章 this 到底指向谁 5 大定律 Rule 1 函数体中，隐式调用函数时，指向 window（nodejs 中是 global）。当然，严格模式下就是 undefined function implicitCall() { console.log(this) } function implicitCallStrict() { 'use strict' console.log(this) } implicitCall() // window implicitCallStrict() // undefined Rule 2 通过 call/apply/bind 显式调用函数时，this 指向指定参数的对象 这里需要注意，如果 bind 返回的函数，用 new 操作符调用，此时 bind 绑定的 this 就会忽略，this 会绑定在示例上 const target = {} // 以下三种写法是等价的 fn.call(target, 'arg1', 'arg2') fn.apply(target, ['arg1', 'arg2']) fn.bind(target, 'arg1', 'arg2')() Rule 3 使用 new 方法调用构造函数时，构造函数内的 this 指向新创建的对象 function Foo() { this.name = 'new method' } const foo = new Foo() console.log(foo.name) // new method Rule 4 通过上下文对象调用函数时，函数体内的 this 指向最后调用它的对象 const contextObject = { name: 'context', fun: function () { return this }, } console.log(contextObject.fun() === contextObject) // true const wrapperContextObject = { name: 'wrapperContext', contextObject, } // 最后调用它的对象时contextObject console.log(wrapperContextObject.contextObject.fun() === contextObject) // true Rule 5 箭头函数中，this 的指向由外层作用域决定 // 利用下setTimeout const normalFunction = { fun: function () { setTimeout(function () { console.log(this === window) }) }, } normalFunction.fun() // true // 使用箭头函数改造下 const arrowFunction = { fun: function () { console.log(this === arrowFunction) }, } arrowFunction.fun() // true By leeson            此页面修订于： 2021-03-31 15:14:31 "},"lodash/":{"url":"lodash/","title":"Lodash","keywords":"","body":"lodash readme By leeson            此页面修订于： 2021-03-31 15:14:31 "},"lodash/1-slice.html":{"url":"lodash/1-slice.html","title":"Slice","keywords":"","body":"slice 截取数组元素,包含 start,不包含 end [start, end) 1. 代码实现 function slice(array, start, end) { let length = array == null ? 0 : array.length if (!length) { return [] } // 默认值 start = start == null ? 0 : start end = end == null ? length : end /** * 处理负值情况 * slice([1, 2, 3], -5) start=0 * 如果绝对值大于数组长度，从0开始 * * slice([1, 2, 3], -1) start=2 * 如果绝对值小于等于数组长度，和数组长度相加 */ if (start length ? 0 : length + start } // end最大为数组的长度 end = end > length ? length : end // end负值大于数组长度后面有控制 会和start比较 if (end >> 是取整操作 length = start > end ? 0 : (end - start) >>> 0 start >>>= 0 /** * 从-1开始 因为while循环中为++index 此时index=0 * 能不能改为index=0 循环使用index++? 不行，因为index++后，index=1 result直接从1开始赋值了。。 */ let index = -1 const result = new Array(length) while (++index By leeson            此页面修订于： 2021-03-31 15:14:31 "},"lodash/2-chunk.html":{"url":"lodash/2-chunk.html","title":"Chunk","keywords":"","body":"chunk 块、片 将数组切分为指定大小的块，一维数组转为指定大小的二维数组 1. 代码实现 // 依赖slice import slice from './1-slice' /** * var array = [1, 2, 3, 4, 5, 6] * chunk(array, 4) * 思路： * 根据size大小确定结果数组长度 * 根据size截取原数组 */ function chunk(array, size = 1) { size = Math.max(size, 0) if (!length || size By leeson            此页面修订于： 2021-03-31 15:14:31 "},"lodash/3-compact.html":{"url":"lodash/3-compact.html","title":"Compact","keywords":"","body":"compact 去除数组中的假值 1. 代码实现 /** * var array = [1, 2, false, 0, 3, undefined, 4] * compact(array) = [1, 2, 3, 4] */ function compact(array) { let resIndex = 0 const result = [] if (!array) { return result } for (const value of array) { if (value) { result[resIndex++] = value } } return result } export default compact By leeson            此页面修订于： 2021-03-31 15:14:31 "},"lodash/4-Hash.html":{"url":"lodash/4-Hash.html","title":"Hash","keywords":"","body":"Hash 接收 1 个二维数组作为参数，转为 key/value 的形式 1. 代码实现 /** * var cache = new Hash([['test1', 1], ['test2', 2]]) * cache.get('test1') // 1 */ // 区分缓存值也是undefined的情况 const HASH_UNDEFINED = '__lodash_hash_undefined__' class Hash { constructor(entires) { let index = -1 const length = entires == null ? 0 : entires.length // 利用clear初始化属性 this.clear() while (++index By leeson            此页面修订于： 2021-03-31 15:14:31 "},"lodash/5-eq.html":{"url":"lodash/5-eq.html","title":"Eq","keywords":"","body":"eq 比较两个参数是否相等，遵循的是 SameValueZero 规范。 1. 代码实现 /** * eq(1, 1) true * eq(1, '1') false * eq(NaN, NaN) true */ function eq(value, other) { /** * value === other 严格相等 * 可以用Object.is()吗？ * 不可以 因为Object.is(+0, -0)返回false */ /** * value !== value && other !== other 处理NaN的情况 * 可以用isNaN()吗？ * 不可以 因为isNaN(value) value会先转为Number再比较 value=undefined或者非空字符串都为trur * * 可以用Number.isNaN()吗 * 可以 es6在Number对象上扩展了isNaN方法，只有是NaN才返回true */ // return value === other || (isNaN(value) && isNaN(other)) return value === other || (value !== value && other !== other) } export default compact By leeson            此页面修订于： 2021-03-31 15:14:31 "},"lodash/6-assocIndexOf.html":{"url":"lodash/6-assocIndexOf.html","title":"Assoc Index Of","keywords":"","body":"assocIndexOf 找出指定 key 在二维数组中的索引值 1. 代码实现 import eq from './5-eq' /** * var array = [['key1', 1], ['key2', 2]] * assocIndexOf(array, 'key1') // 0 * assocIndexOf(array, 'key2') // 1 */ function assocIndexOf(array, key) { let { length } = array /** * length--与--length * 比如length=2 * length-- length * 2 1 * 1 0 * * 如果换成--length length * 1 1 * 0 0 // 循环已结束 漏掉一次循环 */ while (length--) { // 复用eq if (eq(array[length][0], key)) { return length } } return -1 } export default assocIndexOf By leeson            此页面修订于： 2021-03-31 15:14:31 "},"lodash/7-ListCache.html":{"url":"lodash/7-ListCache.html","title":"List Cache","keywords":"","body":"ListCache 和第四个方法类似，ListCache 也是处理缓存的。区别如下： Hash 使用 js 对象做缓存，由于对象的限制，key 只能是 string 或者 Symbol 类型，其他类型就不能使用了，对，可以使用 Map。 ListCache 在不支持 Map 情况下的模拟实现 1. 代码实现 import assocIndexOf from './6-assocIndexOf' /** * new ListCache([ * [{key: 'object key'}: 'object value'], * [['array key']: 'array value'], * [function() {}, 'function value'] * ]) */ class ListCache { // 实现过程和Hash类似 constructor(entries) { let index = -1 const length = entries == null ? 0 : entries.length this.clear() while (++index -1 } set(key, value) { const data = this.__data__ const index = assocIndexOf(data, key) // 不存在则推入 否则更新 if (index By leeson            此页面修订于： 2021-03-31 15:14:31 "},"lodash/8-MapCache.html":{"url":"lodash/8-MapCache.html","title":"Map Cache","keywords":"","body":"MapCache 之前介绍了 Hash 和 MapCache 方法，Hash 利用了 js 对象的 key，value 作为缓存，MapCache 则处理了 js 对象不支持的 key 时的情况。 如果让用户自行来区分使用，成本比较高，如果提供一个通用的方法，根据用户要缓存的数据，自行决定使用哪种方案不是更友好吗？它来了，MapCache 的工作就是这个 1.要点 代码实现和之前的Hash/MapCache类似，第一次看时，比较迷惑的一点是，当可作为对象key时，又单独区分了key类型为string的情况，其他则存到了hash下，这是为什么呢？经过查阅资料，得出以下结论 对象的key，如果不是Symbol类型时，会转为字符串形式 如果缓存的数据中存在数字1和字符串'1'，那么只会存储为字符串1，这就是问题所在了 2. 代码实现 import Hash from './4-Hash' import ListCache from './7-ListCache' /** * new MapCache([ * ['key', 'value'], * [{key: 'An Object Key'}, 1], * [Symbol(),2] * ]) * 返回结果：{ * size: 3, * __data__: {Ï * string: {...}, * hash: {...}, * map: {...} * } * } */ // 是否可作为对象的key function isKeyable(value) { const type = typeof value return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null } function getMapData({ __data__ }, key) { const data = __data__ // 根据是否可用作key 区分使用map return isKeyable(key) ? // 可用作key时 string单独分为1类 data[typeof key == 'string' ? 'string' : 'hash'] : data.map } class MapCache { constructor(entries) { let index = -1 const length = entries == null ? 0 : entries.length this.clear() while (++index By leeson            此页面修订于： 2021-03-31 15:14:31 "},"lodash/9-SetCache.html":{"url":"lodash/9-SetCache.html","title":"Set Cache","keywords":"","body":"SetCache MapCache缓存key/value形式的数据，SetCache提供了更便捷的方式，用于缓存数组中的值，把value作为key，固定标识作为value 1.要点 constructor中new MapCache没有加括号，new对象时，如果不需要传参时，加不加括号都一样，只是调用时需要注意下运算符的优先级 new MapCache().add() // 报错 先执行MapCache.add，因为new运算符的优先级高于. new MapCache.add() 2. 代码实现 import SetCache from './8-MapCache' /** * new SetCache([ * 'value', * 1, * {test: 'Object'} * ]) * 返回结果：{ * size: 3, * __data__: {Ï * string: {...}, * hash: {...}, * map: {...} * } * } */ const HASH_UNDEFINED = '__lodash_hash_undefined__' class SetCache { constructor(values) { let index = -1 const length = values == null ? 0 : values.length this.__data__ = new MapCache while (++index By leeson            此页面修订于： 2021-03-31 15:14:31 "},"lodash/10-baseFindIndex.html":{"url":"lodash/10-baseFindIndex.html","title":"Base Find Index","keywords":"","body":"baseFindIndex 根据条件返回索引值 1.要点 优先级？加个括号不好吗？运算符优先级 // while循环中，源码如下，阅读不太友好，根据优先级加了括号 // 比较运算符的优先级为11，而三元表达式（条件运算符）的优化级为4 fromRight ? index-- : ++index 2. 代码实现 /** * 默认从0开始 * baseFindIndex([1, 4, 3, 2], val => val > 1) // 1 * baseFindIndex([1, 4, 3, 2], val => val > 1, true, 3) // 3 */ function baseFindIndex(array, predicate, fromIndex = 0, fromRight = false) { const { length } = array let index = fromIndex + (fromRight ? 1 : -1) while (fromRight ? index-- : ++index By leeson            此页面修订于： 2021-03-31 15:14:31 "},"lodash/11-strictIndexOf.html":{"url":"lodash/11-strictIndexOf.html","title":"Strict Index Of","keywords":"","body":"strictIndexOf 和原生indexOf一致，采用严格比较查找，区别是这里没有处理fromIndex为负数的情况 1.要点 刚看这个方法是怀疑它的必要性，原生indexOf不能用吗？当然，这也是lodash比较细节的一点，作为内部方法使用 2. 代码实现 /** * strictIndexOf([1, 4, 3, 2], 4) // 1 * strictIndexOf([1, 4, 3, 2], 3) // 2 */ function strictIndexOf(array, value, fromIndex) { let index = fromIndex - 1 const { length } = array while (++index By leeson            此页面修订于： 2021-03-31 15:14:31 "},"其他/1-sula模式学习.html":{"url":"其他/1-sula模式学习.html","title":"sula模式学习","keywords":"","body":"如何设计配置 配置很好实现，关键怎么设计才能更加灵活，一些定制化需求怎么通过不修改库代码实现，如何暴露接口？ 现状 中后台开发中表单是常见需求，需求也是多变的。如果固定了 CRUD 操作接口，后期必然要在源码上堆叠大量特殊逻辑。最近看 formRender、formily，一直在思考表单的配置如何实现，类似这种库的 schema 配置，只做到了 ui 层，事件只实现了简单的显示隐藏、远程数据获取，如果需要对数据获取前后做一些操作，就需要硬编码来实现使用是挺方便，关键是代码，怎么存储到服务端？自定义的如何关联？ Sula 解决了哪些痛点 抽象 action 插件，可以自定义编排 需要自定义功能，可以自定义插件，无缝对接 扩展 field 插件，自定义业务组件 重点是这一切都可以用 json 描述 实现原理 By leeson            此页面修订于： 2021-03-31 15:14:31 "}}