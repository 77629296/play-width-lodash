# 第一章 面向对象的 JavaScript

## 多态的含义

因为 js 是动态类型语言，所以不需要转型来达到多态的效果，这里使用 ts 模拟
同一方法在不同对象上表现不同，比如动物都有发出叫声这个方法，鸡和鸭的声音不同，代码如下

```typescript
// 在线运行ts https://c.runoob.com/compile/5577
abstract class Animal {
  abstract makeSound(): void
}
class Chicken extends Animal {
  public makeSound(): void {
    console.log('咯咯咯')
  }
}
class Duck extends Animal {
  public makeSound(): void {
    console.log('嘎嘎嘎')
  }
}

const chicken: Chicken = new Chicken()
chicken.makeSound() //咯咯咯

const duck: Duck = new Duck()
duck.makeSound() //嘎嘎嘎

// 根据实际类型调用方法
const animalMakeSound = (animal: Duck | Chicken) => {
  animal.makeSound()
}
animalMakeSound(chicken)
animalMakeSound(duck)
```

## 多态的列用

```js
var googleMap = {
  show: function () {
    console.log('开始渲染谷歌地图')
  },
}
var baiduMap = {
  show: function () {
    console.log('开始渲染百度地图')
  },
}

// 后续增加类型 需要修改原代码
var renderMap = function (type) {
  if (type === 'google') {
    googleMap.show()
  } else if (type === 'baidu') {
    baiduMap.show()
  }
}
renderMap('google') // 输出：开始渲染谷歌地图
renderMap('baidu') // 输出：开始渲染百度地图

/**
 * 修改后
 * 抽象相同的show方法，不同的地图对象都实现show方法
 */

var renderMap = function (map) {
  if (map.show instanceof Function) {
    map.show()
  }
}

renderMap(googleMap)
renderMap(baiduMap)

// 新增一种地图时，只需增加地图对象并实现show方法，无需改动renderMap
var sosoMap = {
  show: function () {
    console.log('开始渲染搜搜地图')
  },
}
renderMap(sosoMap) // 输出：开始渲染搜搜地图
```

## 三种创建对象的方式

### 前两种 字面量、object 构造器

从下面这两个判断可以看出 两者是等价的，都是创建一个空的对象，**proto**指向 Object.prototype

```js
// 1、{}
// 2、new Object()
;({}.__proto__ === Object.prototype) // true
new Object().__proto__ === Object.prototype // true
```

### 第三种 Object.create({})

创建一个空的对象 __proto__指向第一个参数

```js
/**
 * 先看一下方法签名
 * proto 必须有，表示新建对象的原型对象
 * propertiesObject 添加到新创建对象的可枚举属性
 */
Object.create(proto, [propertiesObject])

/**
 * 3、Object.create({})
 * 新建一个空对象{}，{}的__proto__指向参数{}
 * 参数{}的__proto__指向Object.prototype
 */

Object.create({}).__proto__.__proto__ === Object.prototype // true
Object.create(Object.prototype).__proto__ === Object.prototype // true

// 新建一个真空对象
Object.create(null)
Object.create(null).__proto__ // undefined
```

### 模拟实现 new 方法

```js
let mockNew = function () {
  let obj = new Object() // 从 Object.prototype 上克隆一个空的对象
  Constructor = [].shift.call(arguments) // 取得外部传入的构造器
  obj.__proto__ = Constructor.prototype // 指向正确的原型
  let ret = Constructor.apply(obj, arguments) // 借用外部传入的构造器给 obj 设置属性
  return typeof ret === 'object' ? ret : obj // 确保构造器总是会返回一个对象
}
```
